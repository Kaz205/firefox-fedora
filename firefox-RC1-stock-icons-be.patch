Index: configure.in
===================================================================
RCS file: /cvsroot/mozilla/configure.in,v
retrieving revision 1.1335.2.6.2.18
diff -u -r1.1335.2.6.2.18 configure.in
--- configure.in	31 Oct 2004 07:17:58 -0000	1.1335.2.6.2.18
+++ configure.in	3 Nov 2004 10:03:35 -0000
@@ -92,6 +92,7 @@
 MAKE_VERSION=3.78
 WINDRES_VERSION=2.14.90
 W32API_VERSION=2.4
+GNOMEUI_VERSION=2.0.6
 GNOMEVFS_VERSION=2.0
 GCONF_VERSION=1.2.1
 LIBGNOME_VERSION=2.0
@@ -3588,7 +3589,35 @@
 
     AC_SUBST(MOZ_ENABLE_GNOME_COMPONENT)
 fi
+dnl = libgnomeui support module
+dnl ========================================================
+
+if test "$MOZ_ENABLE_GTK2"
+then
+    MOZ_ENABLE_GNOMEUI=1
+
+    MOZ_ARG_DISABLE_BOOL(gnomeui,
+    [  --disable-gnomeui       Disable libgnomeui support (default: auto, optional at runtime) ],
+        MOZ_ENABLE_GNOMEUI=,
+        MOZ_ENABLE_GNOMEUI=force)
+
+    if test "$MOZ_ENABLE_GNOMEUI"
+    then
+        PKG_CHECK_MODULES(MOZ_GNOMEUI, libgnomeui-2.0 >= $GNOMEUI_VERSION,
+        [MOZ_ENABLE_GNOMEUI=1], [
+            if test "$MOZ_ENABLE_GNOMEUI" = "force"
+            then
+                AC_MSG_ERROR([* * * Could not find libgnomeui-2.0 >= $GNOMEUI_VERSION])
+            fi
+            MOZ_ENABLE_GNOMEUI=
+        ])
+    fi
 
+    AC_SUBST(MOZ_ENABLE_GNOMEUI)
+    AC_SUBST(MOZ_GNOMEUI_CFLAGS)
+    AC_SUBST(MOZ_GNOMEUI_LIBS)
+
+fi
 dnl ========================================================
 dnl = Setting MOZ_EXTRA_X11CONVERTERS turns on additional 
 dnl = converters in intl/uconv that are used only by X11 gfx 
@@ -3999,6 +4028,17 @@
         MOZ_IMG_DECODERS_DEFAULT="$MOZ_IMG_DECODERS_DEFAULT icon"
     fi
     ;;
+*)
+    if test "$MOZ_ENABLE_GNOMEUI"; then
+
+        MOZ_IMG_DECODERS_DEFAULT="$MOZ_IMG_DECODERS_DEFAULT icon"
+    fi
+    ;;
+*)
+    if test "$MOZ_ENABLE_GNOMEUI"; then
+        MOZ_IMG_DECODERS_DEFAULT="$MOZ_IMG_DECODERS_DEFAULT icon"
+    fi
+    ;;
 esac
 
 MOZ_ARG_ENABLE_STRING(image-decoders,
Index: config/autoconf.mk.in
===================================================================
RCS file: /cvsroot/mozilla/config/autoconf.mk.in,v
retrieving revision 3.310.6.7
diff -u -r3.310.6.7 autoconf.mk.in
--- config/autoconf.mk.in	31 Oct 2004 04:29:54 -0000	3.310.6.7
+++ config/autoconf.mk.in	3 Nov 2004 10:03:54 -0000
@@ -165,8 +165,14 @@
 endif
 endif
 MOZ_LIBART_LIBS = @MOZ_LIBART_LIBS@
+
 MOZ_CAIRO_LIBS = @MOZ_CAIRO_LIBS@
 
+MOZ_ENABLE_GNOMEUI = @MOZ_ENABLE_GNOMEUI@
+MOZ_GNOMEUI_CFLAGS = @MOZ_GNOMEUI_CFLAGS@
+MOZ_GNOMEUI_LIBS = @MOZ_GNOMEUI_LIBS@
+
+
 MOZ_GNOMEVFS_CFLAGS = @MOZ_GNOMEVFS_CFLAGS@
 MOZ_GNOMEVFS_LIBS = @MOZ_GNOMEVFS_LIBS@
 
Index: modules/libpr0n/decoders/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/Makefile.in,v
retrieving revision 1.10
diff -u -r1.10 Makefile.in
--- modules/libpr0n/decoders/Makefile.in	1 Jul 2003 03:57:24 -0000	1.10
+++ modules/libpr0n/decoders/Makefile.in	3 Nov 2004 10:03:59 -0000
@@ -29,6 +29,9 @@
 DIRS		= $(MOZ_IMG_DECODERS)
 
 ifneq (,$(findstring icon,$(MOZ_IMG_DECODERS)))
+ifdef MOZ_ENABLE_GNOMEUI
+DIRS    := icon/gtk $(DIRS)
+endif
 ifeq ($(OS_ARCH),WINNT)
 DIRS		:= icon/win $(DIRS)
 endif
@@ -39,6 +42,9 @@
 DIRS		:= icon/mac $(DIRS)
 endif
 endif # icon
+ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
+DIRS		:= icon/gtk $(DIRS)
+endif
 
 include $(topsrcdir)/config/rules.mk
 
Index: modules/libpr0n/decoders/icon/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/Makefile.in,v
retrieving revision 1.9.20.1
diff -u -r1.9.20.1 Makefile.in
--- modules/libpr0n/decoders/icon/Makefile.in	22 Jun 2004 22:37:07 -0000	1.9.20.1
+++ modules/libpr0n/decoders/icon/Makefile.in	3 Nov 2004 10:03:59 -0000
@@ -35,6 +35,13 @@
 
 PACKAGE_FILE = imgicon.pkg
 
+ifdef MOZ_ENABLE_GNOMEUI
+EXTRA_DSO_LDOPTS = $(MOZ_GNOMEUI_LIBS)
+PLATFORM = gtk
+FORCE_SHARED_LIB = 1
+EXPORT_LIBRARY =
+endif
+
 ifeq ($(OS_ARCH),WINNT)
 EXTRA_DSO_LIBS	= gkgfx
 PLATFORM = win
@@ -48,6 +55,10 @@
 PLATFORM = mac
 endif
 
+ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
+PLATFORM = gtk
+endif
+
 DIRS		= $(PLATFORM)
 
 REQUIRES	= xpcom \
@@ -68,7 +79,7 @@
 
 SHARED_LIBRARY_LIBS = $(DIST)/lib/$(LIB_PREFIX)imgicon$(PLATFORM)_s.$(LIB_SUFFIX)
 
-EXTRA_DSO_LDOPTS = \
+EXTRA_DSO_LDOPTS += \
 		$(EXTRA_DSO_LIBS) \
 		$(MOZ_COMPONENT_LIBS) \
 		$(NULL)
Index: modules/libpr0n/decoders/icon/nsIIconURI.idl
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/nsIIconURI.idl,v
retrieving revision 1.5
diff -u -r1.5 nsIIconURI.idl
--- modules/libpr0n/decoders/icon/nsIIconURI.idl	27 Apr 2002 05:32:16 -0000	1.5
+++ modules/libpr0n/decoders/icon/nsIIconURI.idl	3 Nov 2004 10:03:59 -0000
@@ -21,26 +21,90 @@
 
 #include "nsIURI.idl"
 
-//
-//  moz-icon URLs have the following syntax
-// 
-//  moz-icon:<file-uri>?size=16&contentType=text/html
-// OR
-// moz-icon://dummyfile.html
-// moz-icon://dummyfile.html?size=32
-// 
-//  The content type field is optional. The size field is optional. You only need to specify a file url inside the icon
-// if the file you want the icon for actually exists. Otherwise you can omit the file:// and just place a dummy file name with the extension
-// or content type you want: moz-icon://dummy.html. 
-// 
+  /**
+   * nsIIconURI
+   *
+   * This interface derives from nsIURI, to provide additional information
+   * about moz-icon URIs.  These URIs
+   *
+   * What *is* a moz-icon URI you ask?  Well, it has the following syntax:
+   *
+   * moz-icon://[<file-uri> | <file-with-extension>]? ['?'[<parameter-value-pairs>]]
+   *
+   * <file-uri> is a legal file: URI spec.  You only need to specify a file: URI inside the icon
+   * if the file you want the icon for actually exists.
+   *
+   * <file-with-extension> is any filename with an extension, e.g. "dummy.html".
+   * If the file you want an icon for isn't known to exist, you can omit the file URI, and just
+   * place a dummy file name with the extension or content type you want: moz-icon://dummy.html.
+   *
+   * <stock-image> is of the format:   stock/<icon-name>
+   *
+   * <icon-name> is a valid icon name, such as 'ok', 'cancel', 'yes', 'no'.
+   * XXXcaa document or reference to all 76 (yes, 76) of them.
+   *
+   * Legal parameter value pairs are listed below:
+   *
+   *   Parameter:   size
+   *   Values:      [<integer> | button | toolbar | toolbarsmall | menu | dialog]
+   *   Description: If integer, this is the desired size in square pixels of the icon
+   *                Else, use the OS default for the specified keyword context.
+   *                Note that stock images require a keyword, not an integer pixel value.
+   *
+   *   Parameter:   contentType
+   *   Values:      <mime-type>
+   *   Description: A valid mime type for the icon.
+   */
 
 [scriptable, uuid(733A7A16-2D36-11d5-9907-001083010E9B)]
 interface nsIMozIconURI : nsIURI 
 {
-  // Returns the file URL contained within this -moz-icon url.
-  attribute nsIURI IconFile; // maybe null if there isn't a real file we are trying to fetch
+  /**
+   * iconFile
+   *
+   * the file URL contained within this moz-icon url, or null.
+   */
+  attribute nsIURI iconFile;
+  /**
+   * imageSize
+   *
+   * The image area in square pixels, defaulting to 16 if unspecified.
+   */
+  attribute unsigned long imageSize;
 
-  attribute unsigned long imageSize; // measured by # of pixels in a row. defaults to 16.
-  attribute ACString contentType;      // may be an empty string
+  /**
+   * contentType
+   *
+   * A valid mime type, or the empty string.
+   */
+
+  attribute ACString contentType;
+
+  /**
+   * fileExtension
+   *
+   * The file extension of the file which we are looking up.
+   */
   readonly attribute ACString fileExtension;    
+
+  /**
+   * stockIcon
+   *
+   * The stock icon name requested from the OS.
+   */
+   readonly attribute ACString stockIcon;
+
+  /**
+   * stockIconSize
+   *
+   * The stock icon size requested from the OS.
+   */
+   readonly attribute ACString stockIconSize;
+
+  /**
+   * stockIconState
+   *
+   * The stock icon state requested from the OS.
+   */
+   readonly attribute ACString stockIconState;
 };
Index: modules/libpr0n/decoders/icon/nsIconModule.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/nsIconModule.cpp,v
retrieving revision 1.4
diff -u -r1.4 nsIconModule.cpp
--- modules/libpr0n/decoders/icon/nsIconModule.cpp	30 Jan 2002 21:05:40 -0000	1.4
+++ modules/libpr0n/decoders/icon/nsIconModule.cpp	3 Nov 2004 10:03:59 -0000
@@ -26,6 +26,7 @@
 
 #include "nsIconDecoder.h"
 #include "nsIconProtocolHandler.h"
+#include "nsIconURI.h"
 
 // objects that just require generic constructors
 /******************************************************************************
@@ -41,7 +42,8 @@
   { "icon decoder",
     NS_ICONDECODER_CID,
     "@mozilla.org/image/decoder;2?type=image/icon",
-    nsIconDecoderConstructor, },
+    nsIconDecoderConstructor
+  },
 
    { "Icon Protocol Handler",      
       NS_ICONPROTOCOL_CID,
@@ -50,4 +52,12 @@
     }
 };
 
-NS_IMPL_NSGETMODULE(nsIconDecoderModule, components)
+PR_STATIC_CALLBACK(nsresult)
+IconDecoderModuleCtor(nsIModule* aSelf)
+{
+  nsMozIconURI::InitAtoms();
+  return NS_OK;
+}
+
+NS_IMPL_NSGETMODULE_WITH_CTOR(nsIconDecoderModule, components,
+                              IconDecoderModuleCtor)
Index: modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp,v
retrieving revision 1.12
diff -u -r1.12 nsIconProtocolHandler.cpp
--- modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp	8 Jan 2003 22:02:55 -0000	1.12
+++ modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp	3 Nov 2004 10:03:59 -0000
@@ -89,15 +89,18 @@
 
 NS_IMETHODIMP nsIconProtocolHandler::NewChannel(nsIURI* url, nsIChannel* *result)
 {
-  nsCOMPtr<nsIChannel> channel;
-  NS_NEWXPCOM(channel, nsIconChannel);
+  nsIconChannel* channel = new nsIconChannel;
+  if (!channel)
+    return NS_ERROR_OUT_OF_MEMORY;
+  NS_ADDREF(channel);
 
-  if (channel)
-    NS_STATIC_CAST(nsIconChannel*,NS_STATIC_CAST(nsIChannel*, channel))->Init(url);
+  nsresult rv = channel->Init(url);
+  if (NS_FAILED(rv)) {
+    delete channel;
+    return rv;
+  }
 
   *result = channel;
-  NS_IF_ADDREF(*result);
-
   return NS_OK;
 }
 
Index: modules/libpr0n/decoders/icon/nsIconURI.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/nsIconURI.cpp,v
retrieving revision 1.16
diff -u -r1.16 nsIconURI.cpp
--- modules/libpr0n/decoders/icon/nsIconURI.cpp	17 Mar 2004 21:23:51 -0000	1.16
+++ modules/libpr0n/decoders/icon/nsIconURI.cpp	3 Nov 2004 10:03:59 -0000
@@ -26,6 +26,8 @@
 #include "nsCRT.h"
 #include "nsReadableUtils.h"
 #include "nsPrintfCString.h"
+#include "nsIAtom.h"
+#include "nsStaticAtom.h"
 
 static NS_DEFINE_CID(kIOServiceCID,     NS_IOSERVICE_CID);
 #define DEFAULT_IMAGE_SIZE          16
@@ -34,17 +36,48 @@
 // from the icon url.
 static void extractAttributeValue(const char * searchString, const char * attributeName, char ** result);
  
+static nsIAtom *sStockSizeButton = nsnull;
+static nsIAtom *sStockSizeToolbar = nsnull;
+static nsIAtom *sStockSizeToolbarsmall = nsnull;
+static nsIAtom *sStockSizeMenu = nsnull;
+static nsIAtom *sStockSizeDialog = nsnull;
+static nsIAtom *sStockStateNormal = nsnull;
+static nsIAtom *sStockStateDisabled = nsnull;
+
+/* static */ const nsStaticAtom nsMozIconURI::sSizeAtoms[] =
+{
+  { "button", &sStockSizeButton },
+  { "toolbar", &sStockSizeToolbar },
+  { "toolbarsmall", &sStockSizeToolbarsmall },
+  { "menu", &sStockSizeMenu },
+  { "dialog", &sStockSizeDialog }
+};
+
+/* static */ const nsStaticAtom nsMozIconURI::sStateAtoms[] =
+{
+  { "normal", &sStockStateNormal },
+  { "disabled", &sStockStateDisabled }
+};
+
 ////////////////////////////////////////////////////////////////////////////////
  
 nsMozIconURI::nsMozIconURI()
+  : mSize(DEFAULT_IMAGE_SIZE)
 {
-  mSize = DEFAULT_IMAGE_SIZE;
 }
  
 nsMozIconURI::~nsMozIconURI()
 {
 }
 
+
+/* static */ void
+nsMozIconURI::InitAtoms()
+{
+  NS_RegisterStaticAtoms(sSizeAtoms, NS_ARRAY_LENGTH(sSizeAtoms));
+  NS_RegisterStaticAtoms(sStateAtoms, NS_ARRAY_LENGTH(sStateAtoms));
+}
+
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsMozIconURI, nsIMozIconURI, nsIURI)
 
 #define NS_MOZICON_SCHEME           "moz-icon:"
@@ -64,6 +97,26 @@
     NS_ENSURE_SUCCESS(rv, rv);
     spec += fileIconSpec;
   }
+  else if (!mStockIcon.IsEmpty())
+  {
+    spec += "//stock/";
+    spec += mStockIcon;
+    if (mStockIconSize) {
+      spec += NS_MOZ_ICON_DELIMITER;
+      spec += "size=";
+      const char *size_string;
+      mStockIconSize->GetUTF8String(&size_string);
+      spec.Append(nsPrintfCString("%s", size_string));
+    }
+    if (mStockIconState) {
+      spec += NS_MOZ_ICON_DELIMITER;
+      spec += "state=";
+      const char *state_string;
+      mStockIconSize->GetUTF8String(&state_string);
+      spec.Append(nsPrintfCString("%s", state_string));
+    }
+    return NS_OK;
+  }
   else
   {
     spec += "//";
@@ -116,12 +169,10 @@
 				else // there is nothing left so eat up rest of line.
 					attributeValue = PL_strdup(startOfAttribute);
 			} // if we have a attribute value
-
 		} // if we have a attribute name
 	} // if we got non-null search string and attribute name values
 
   *result = attributeValue; // passing ownership of attributeValue into result...no need to 
-	return;
 }
 
 NS_IMETHODIMP
@@ -138,6 +189,8 @@
   if (strcmp("moz-icon", scheme.get()) != 0) 
     return NS_ERROR_MALFORMED_URI;
 
+  nsXPIDLCString sizeString;
+  nsXPIDLCString stateString;
   nsCAutoString mozIconPath(aSpec);
   PRInt32 endPos = mozIconPath.FindChar(':') + 1; // guaranteed to exist!
   PRInt32 pos = mozIconPath.FindChar(NS_MOZ_ICON_DELIMITER);
@@ -150,26 +203,48 @@
   {
     mozIconPath.Mid(mDummyFilePath, endPos, pos - endPos);
     // fill in any size and content type values...
-    nsXPIDLCString sizeString;
     nsXPIDLCString contentTypeString;
     extractAttributeValue(mozIconPath.get() + pos, "size=", getter_Copies(sizeString));
+    extractAttributeValue(mozIconPath.get() + pos, "state=", getter_Copies(stateString));
     extractAttributeValue(mozIconPath.get() + pos, "contentType=", getter_Copies(contentTypeString));
     mContentType = contentTypeString;
-
-    if (sizeString.get())
-    {
-      PRInt32 sizeValue = atoi(sizeString);
-      // if the size value we got back is > 0 then use it
-      if (sizeValue)
-        mSize = sizeValue;
-    }
   }
 
-  // Okay now we have a bit of a hack here...filePath can have two forms:
+  // Okay now we have a bit of a hack here...filePath can have three forms:
   // (1) file://<some valid platform specific file url>
   // (2) //<some dummy file with an extension>
+  // (3) stock/<icon-identifier>
   // We need to determine which case we are and behave accordingly...
-  if (mDummyFilePath.Length() > 2) // we should at least have two forward slashes followed by a file or a file://
+  if (mDummyFilePath.Length() > 2)
+  {
+    if (!strncmp("//stock/", mDummyFilePath.get(), 8))
+    {
+      // we have a stock icon
+      mStockIcon = Substring(mDummyFilePath, 8);
+      if (!sizeString.IsEmpty())
+      {
+        nsCOMPtr<nsIAtom> atom = do_GetAtom(sizeString);
+        for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sSizeAtoms); i++)
+        {
+          if (atom == *(sSizeAtoms[i].mAtom))
+          {
+            mStockIconSize = atom;
+            break;
+          }
+        }
+
+        atom = do_GetAtom(stateString);
+        for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sStateAtoms); i++)
+        {
+          if (atom == *(sStateAtoms[i].mAtom))
+          {
+            mStockIconState = atom;
+            break;
+          }
+        }
+      }
+    }
+    else
   {
     if (!nsCRT::strncmp("//", mDummyFilePath.get(), 2))// must not have a url here..
     {
@@ -177,16 +252,22 @@
       // and remember the rest in mDummyFilePath
       mDummyFilePath.Cut(0, 2); // cut the first 2 bytes....
     }
-
-    if (!nsCRT::strncmp("file://", mDummyFilePath.get(), 7))
+      else if (!nsCRT::strncmp("file://", mDummyFilePath.get(), 7))
     { 
       // we have a file url.....so store it...
       rv = ioService->NewURI(mDummyFilePath, nsnull, nsnull, getter_AddRefs(mFileIcon));
-      if (NS_FAILED(rv)) return NS_ERROR_MALFORMED_URI;
+      }
+      if (!sizeString.IsEmpty())
+      {
+        PRInt32 sizeValue = atoi(sizeString);
+        // if the size value we got back is > 0 then use it
+        if (sizeValue)
+          mSize = sizeValue;
+      }
     }
   }
   else
-    return NS_ERROR_MALFORMED_URI; // they didn't include a file path...
+    rv = NS_ERROR_MALFORMED_URI; // they didn't include a file path...
   return rv;
 }
 
@@ -436,10 +517,35 @@
   const char * chFileName = fileExtension.get(); // get the underlying buffer
   const char * fileExt = strrchr(chFileName, '.');
   if (!fileExt) return NS_ERROR_FAILURE; // no file extension to work from.
-  else
+
     aFileExtension = nsDependentCString(fileExt);
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsMozIconURI::GetStockIcon(nsACString &aStockIcon)
+{
+  aStockIcon.Assign(mStockIcon);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMozIconURI::GetStockIconSize(nsACString &aSize)
+{
+  if (mStockIconSize)
+    return mStockIconSize->ToUTF8String(aSize);
+  aSize.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMozIconURI::GetStockIconState(nsACString &aState)
+{
+  if (mStockIconState)
+    return mStockIconState->ToUTF8String(aState);
+  aState.Truncate();
+  return NS_OK;
+}
 ////////////////////////////////////////////////////////////////////////////////
Index: modules/libpr0n/decoders/icon/nsIconURI.h
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/nsIconURI.h,v
retrieving revision 1.6
diff -u -r1.6 nsIconURI.h
--- modules/libpr0n/decoders/icon/nsIconURI.h	6 Mar 2002 07:47:49 -0000	1.6
+++ modules/libpr0n/decoders/icon/nsIconURI.h	3 Nov 2004 10:04:00 -0000
@@ -25,6 +25,9 @@
 #include "nsIIconURI.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
+class nsStaticAtom;
+
+class nsIAtom;
 
 #define NS_MOZICONURI_CID                            \
 {                                                    \
@@ -41,6 +44,8 @@
   NS_DECL_NSIURI
   NS_DECL_NSIMOZICONURI
 
+  static void InitAtoms();
+
   // nsJARURI
   nsMozIconURI();
   virtual ~nsMozIconURI();
@@ -50,6 +55,12 @@
   PRUint32 mSize; // the # of pixels in a row that we want for this image. Typically 16, 32, 128, etc.
   nsCString mContentType; // optional field explicitly specifying the content type
   nsCString mDummyFilePath; // if we don't have a valid file url, the file path is stored here....i.e if mFileIcon is null.....
+  nsCString mStockIcon;
+  nsCOMPtr<nsIAtom> mStockIconSize;
+  nsCOMPtr<nsIAtom> mStockIconState;
+
+  static const nsStaticAtom sSizeAtoms[];
+  static const nsStaticAtom sStateAtoms[];
 
   nsresult FormatSpec(nsACString &result);
 };
Index: modules/libpr0n/decoders/icon/win/nsIconChannel.h
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/win/nsIconChannel.h,v
retrieving revision 1.6
diff -u -r1.6 nsIconChannel.h
--- modules/libpr0n/decoders/icon/win/nsIconChannel.h	19 Dec 2003 15:04:27 -0000	1.6
+++ modules/libpr0n/decoders/icon/win/nsIconChannel.h	3 Nov 2004 10:04:00 -0000
@@ -45,7 +45,7 @@
   NS_DECL_NSISTREAMLISTENER
 
   nsIconChannel();
-  virtual ~nsIconChannel();
+  ~nsIconChannel();
 
   nsresult Init(nsIURI* uri);
 
Index: caps/src/nsScriptSecurityManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/caps/src/nsScriptSecurityManager.cpp,v
retrieving revision 1.229.6.6
diff -u -r1.229.6.6 nsScriptSecurityManager.cpp
--- caps/src/nsScriptSecurityManager.cpp	24 Oct 2004 12:04:33 -0000	1.229.6.6
+++ caps/src/nsScriptSecurityManager.cpp	3 Nov 2004 10:11:43 -0000
@@ -1233,6 +1233,7 @@
         //   to increase performance
         { "http",            AllowProtocol  },
         { "chrome",          ChromeProtocol },
+        { "moz-icon",	     ChromeProtocol },
         { "file",            PrefControlled },
         { "https",           AllowProtocol  },
         { "mailbox",         DenyProtocol   },
--- /dev/null	2004-11-03 10:29:10.174421952 +0100
+++ modules/libpr0n/decoders/icon/gtk/Makefile.in	2004-10-17 15:14:05.000000000 +0200
@@ -0,0 +1,63 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Makefile for the Gnome icon decoder.
+#
+# The Initial Developer of the Original Code is
+# Christian Biesinger <cbiesinger@web.de>.
+# Portions created by the Initial Developer are Copyright (C) 2004
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+
+DEPTH		= ../../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= imgicon
+LIBRARY_NAME	= imgicongtk_s
+
+REQUIRES	= xpcom \
+		  string \
+		  necko \
+		  intl \
+		  mimetype \
+		  $(NULL)
+
+CPPSRCS		= nsIconChannel.cpp
+
+LOCAL_INCLUDES += $(MOZ_GNOMEUI_CFLAGS) $(MOZ_GTK2_CFLAGS)
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+
+include $(topsrcdir)/config/rules.mk
+
--- /dev/null	2004-11-03 10:29:10.174421952 +0100
+++ modules/libpr0n/decoders/icon/gtk/nsIconChannel.h	2004-10-17 15:14:05.000000000 +0200
@@ -0,0 +1,84 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for gnome.
+ *
+ * The Initial Developer of the Original Code is
+ * Christian Biesinger <cbiesinger@web.de>.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsIconChannel_h_
+#define nsIconChannel_h_
+
+#include "nsIChannel.h"
+#include "nsIStreamListener.h"
+#include "nsIURI.h"
+#include "nsIIconURI.h"
+#include "nsCOMPtr.h"
+
+/**
+ * This class is the gnome implementation of nsIconChannel. It basically asks
+ * gtk/gnome for an icon, saves it as a tmp icon, and creates a new channel for
+ * that file to which all calls will be proxied.
+ */
+class nsIconChannel : public nsIChannel
+{
+  public:
+    NS_DECL_ISUPPORTS
+    NS_FORWARD_NSIREQUEST(mRealChannel->)
+    NS_FORWARD_NSICHANNEL(mRealChannel->)
+
+    nsIconChannel() {}
+    ~nsIconChannel() {}
+
+    /**
+     * Called by nsIconProtocolHandler after it creates this channel.
+     * Must be called before calling any other function on this object.
+     * If this method fails, no other function must be called on this object.
+     */
+    NS_HIDDEN_(nsresult) Init(nsIURI* aURI);
+  private:
+    /**
+     * The channel to the temp icon file (e.g. to /tmp/2qy9wjqw.html).
+     * Will always be non-null after a successful Init.
+     */
+    nsCOMPtr<nsIChannel> mRealChannel;
+    /**
+     * The moz-icon URI we're loading. Always non-null after a successful Init.
+     */
+    nsCOMPtr<nsIMozIconURI> mURI;
+
+    /**
+     * Called by Init if we need to use the gnomeui library.
+     */
+    nsresult InitWithGnome();
+};
+
+#endif
--- /dev/null	2004-11-03 10:29:10.174421952 +0100
+++ modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp	2004-10-23 12:15:15.000000000 +0200
@@ -0,0 +1,352 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla icon channel for gnome.
+ *
+ * The Initial Developer of the Original Code is
+ * Christian Biesinger <cbiesinger@web.de>.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include <stdlib.h>
+#include <unistd.h>
+// Older versions of these headers seem to be missing an extern "C"
+extern "C" {
+#include <libgnome/libgnome.h>
+#include <libgnomeui/gnome-icon-theme.h>
+#include <libgnomeui/gnome-icon-lookup.h>
+#include <libgnomeui/gnome-ui-init.h>
+
+#include <libgnomevfs/gnome-vfs-file-info.h>
+#include <libgnomevfs/gnome-vfs-ops.h>
+}
+
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+
+#include "nsIMIMEService.h"
+
+#include "nsIStringBundle.h"
+
+#include "nsEscape.h"
+#include "nsNetUtil.h"
+#include "nsIURL.h"
+#include "prlink.h"
+#include "nsIconChannel.h"
+
+NS_IMPL_ISUPPORTS2(nsIconChannel, nsIRequest, nsIChannel)
+
+/**
+ * Given a path to a PNG Image, creates a channel from it.
+ * Note that the channel will delete the file when it's done with it.
+ *
+ * (When this function fails, the file will NOT be deleted)
+ */
+static nsresult pngfile_to_channel(const char* aFilename, nsIChannel** aChannel) {
+  // Now we have to create an uri for the file...
+  nsCOMPtr<nsILocalFile> lf;
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(aFilename), PR_FALSE,
+                                      getter_AddRefs(lf));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIInputStream> is;
+  rv = NS_NewLocalFileInputStream(getter_AddRefs(is), lf, -1, -1,
+                                  nsIFileInputStream::DELETE_ON_CLOSE);
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIURI> realURI;
+  rv = NS_NewFileURI(getter_AddRefs(realURI), lf);
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = NS_NewInputStreamChannel(aChannel, realURI, is,
+                                NS_LITERAL_CSTRING("image/png"));
+  return rv;
+}
+
+static nsresult
+moz_gdk_pixbuf_to_channel(GdkPixbuf* aPixbuf, nsIChannel **aChannel)
+{
+  char tmpfile[] = "/tmp/moziconXXXXXX";
+  int fd = mkstemp(tmpfile);
+  if (fd == -1) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  GError *err = NULL;
+  gboolean ok = gdk_pixbuf_save(aPixbuf, tmpfile, "png", &err, NULL);
+  if (!ok) {
+    close(fd);
+    remove(tmpfile);
+    if (err)
+      g_error_free(err);
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  nsresult rv = pngfile_to_channel(tmpfile, aChannel);
+  close(fd);
+  if (NS_FAILED(rv))
+    remove(tmpfile);
+  return rv;
+}
+
+static GtkWidget *gProtoWindow = nsnull;
+static GtkWidget *gStockImageWidget = nsnull;
+static GtkIconFactory *gIconFactory = nsnull;
+
+static void
+ensure_stock_image_widget()
+{
+    if (!gProtoWindow) {
+        gProtoWindow = gtk_window_new(GTK_WINDOW_POPUP);
+        gtk_widget_realize(gProtoWindow);
+        GtkWidget* protoLayout = gtk_fixed_new();
+        gtk_container_add(GTK_CONTAINER(gProtoWindow), protoLayout);
+
+        gStockImageWidget = gtk_image_new();
+        gtk_container_add(GTK_CONTAINER(protoLayout), gStockImageWidget);
+        gtk_widget_realize(gStockImageWidget);
+    }
+}
+
+static void
+ensure_icon_factory()
+{
+  if (!gIconFactory) {
+    gIconFactory = gtk_icon_factory_new();
+    gtk_icon_factory_add_default (gIconFactory);
+    g_object_unref(gIconFactory);
+  }
+}
+
+static GtkIconSize
+moz_gtk_icon_size(const char *name)
+{
+  if (strcmp(name, "button") == 0)
+    return GTK_ICON_SIZE_BUTTON;
+
+  if (strcmp(name, "menu") == 0)
+    return GTK_ICON_SIZE_MENU;
+
+  if (strcmp(name, "toolbar") == 0)
+    return GTK_ICON_SIZE_LARGE_TOOLBAR;
+
+  if (strcmp(name, "toolbarsmall") == 0)
+    return GTK_ICON_SIZE_SMALL_TOOLBAR;
+
+  if (strcmp(name, "dialog") == 0)
+    return GTK_ICON_SIZE_DIALOG;
+
+  return GTK_ICON_SIZE_INVALID;
+}
+
+nsresult
+nsIconChannel::InitWithGnome()
+{
+  if (!gnome_program_get()) {
+    // Get the brandShortName from the string bundle to pass to GNOME
+    // as the application name.  This may be used for things such as
+    // the title of grouped windows in the panel.
+    nsCOMPtr<nsIStringBundleService> bundleService = 
+      do_GetService(NS_STRINGBUNDLE_CONTRACTID);
+
+    NS_ASSERTION(bundleService, "String bundle service must be present!");
+
+    nsCOMPtr<nsIStringBundle> bundle;
+    bundleService->CreateBundle("chrome://global/locale/brand.properties",
+                                getter_AddRefs(bundle));
+    nsXPIDLString appName;
+
+    if (bundle) {
+      bundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
+                                getter_Copies(appName));
+    } else {
+      NS_WARNING("brand.properties not present, using default application name");
+      appName.Assign(NS_LITERAL_STRING("Gecko"));
+    }
+
+    char* empty[] = { "" };
+    gnome_init(NS_ConvertUTF16toUTF8(appName).get(), "1.0", 1, empty);
+  }
+
+  PRUint32 iconSize;
+  nsresult rv = mURI->GetImageSize(&iconSize);
+  NS_ASSERTION(NS_SUCCEEDED(rv), "GetImageSize failed");
+
+  nsCAutoString type;
+  mURI->GetContentType(type);
+
+  GnomeVFSFileInfo fileInfo = {0};
+  fileInfo.refcount = 1; // In case some GnomeVFS function addrefs and releases it
+
+  nsCAutoString spec;
+  nsCOMPtr<nsIURI> fileURI;
+  rv = mURI->GetIconFile(getter_AddRefs(fileURI));
+  if (fileURI) {
+    fileURI->GetAsciiSpec(spec);
+    // Only ask gnome-vfs for a GnomeVFSFileInfo for file: uris, to avoid a
+    // network request
+    PRBool isFile;
+    if (NS_SUCCEEDED(fileURI->SchemeIs("file", &isFile)) && isFile) {
+      gnome_vfs_get_file_info(spec.get(), &fileInfo, GNOME_VFS_FILE_INFO_DEFAULT);
+    }
+    else {
+      // We have to get a leaf name from our uri...
+      nsCOMPtr<nsIURL> url(do_QueryInterface(fileURI));
+      if (url) {
+        nsCAutoString name;
+        // The filename we get is UTF-8-compatible, which matches gnome expectations.
+        // See also: http://lists.gnome.org/archives/gnome-vfs-list/2004-March/msg00049.html
+        // "Whenever we can detect the charset used for the URI type we try to
+        //  convert it to/from utf8 automatically inside gnome-vfs."
+        // I'll interpret that as "otherwise, this field is random junk".
+        url->GetFileName(name);
+        fileInfo.name = g_strdup(name.get());
+      }
+      // If this is no nsIURL, nothing we can do really.
+
+      if (!type.IsEmpty()) {
+        fileInfo.valid_fields = GNOME_VFS_FILE_INFO_FIELDS_MIME_TYPE;
+        fileInfo.mime_type = g_strdup(type.get());
+      }
+    }
+  }
+
+
+  if (type.IsEmpty()) {
+    nsCOMPtr<nsIMIMEService> ms(do_GetService("@mozilla.org/mime;1"));
+    if (ms) {
+      nsCAutoString fileExt;
+      mURI->GetFileExtension(fileExt);
+      nsXPIDLCString extType;
+      ms->GetTypeFromExtension(fileExt.get(), getter_Copies(extType));
+      fileExt.Assign(extType);
+    }
+  }
+
+  // Get the icon theme
+  GnomeIconTheme *t = gnome_icon_theme_new();
+  if (!t) {
+    gnome_vfs_file_info_clear(&fileInfo);
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+ 
+
+  char* name = gnome_icon_lookup(t, NULL, spec.get(), NULL, &fileInfo, type.get(), GNOME_ICON_LOOKUP_FLAGS_NONE, NULL);
+  gnome_vfs_file_info_clear(&fileInfo);
+  if (!name) {
+    g_object_unref(G_OBJECT(t));
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+ 
+  char* file = gnome_icon_theme_lookup_icon(t, name, iconSize, NULL, NULL);
+  g_free(name);
+  g_object_unref(G_OBJECT(t));
+  if (!file)
+    return NS_ERROR_NOT_AVAILABLE;
+
+  // Create a GdkPixbuf buffer and scale it
+  GError *err = nsnull;
+  GdkPixbuf* buf = gdk_pixbuf_new_from_file(file, &err);
+  g_free(file);
+  if (!buf) {
+    if (err)
+      g_error_free(err);
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // scale...
+  GdkPixbuf* scaled = gdk_pixbuf_scale_simple(buf, iconSize, iconSize, GDK_INTERP_BILINEAR);
+  gdk_pixbuf_unref(buf);
+  if (!scaled)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  rv = moz_gdk_pixbuf_to_channel(scaled, getter_AddRefs(mRealChannel));
+  gdk_pixbuf_unref(scaled);
+  return rv;
+}
+
+nsresult
+nsIconChannel::Init(nsIURI* aURI) {
+  mURI = do_QueryInterface(aURI);
+  NS_ASSERTION(mURI, "URI passed to nsIconChannel is no nsIMozIconURI!");
+
+  nsCAutoString stockIcon;
+  mURI->GetStockIcon(stockIcon);
+  if (stockIcon.IsEmpty()) {
+    return InitWithGnome();
+  }
+
+  nsCAutoString iconSizeString;
+  mURI->GetStockIconSize(iconSizeString);
+
+  nsCAutoString iconStateString;
+  mURI->GetStockIconState(iconStateString);
+
+  GtkIconSize icon_size = moz_gtk_icon_size(iconSizeString.get());
+  if (icon_size == GTK_ICON_SIZE_INVALID) {
+    NS_WARNING(iconSizeString.get());
+    return NS_ERROR_FAILURE;
+  }
+   
+  ensure_stock_image_widget();
+
+  gboolean sensitive = strcmp(iconStateString.get(), "disabled");
+  gtk_widget_set_sensitive (gStockImageWidget, sensitive);
+  
+  GdkPixbuf *icon = gtk_widget_render_icon(gStockImageWidget, stockIcon.get(),
+                                           icon_size, NULL);
+  if (!icon) {
+    ensure_icon_factory();
+      
+    GtkIconSet *icon_set = gtk_icon_set_new();
+    GtkIconSource *icon_source = gtk_icon_source_new();
+    
+    gtk_icon_source_set_icon_name(icon_source, stockIcon.get());
+    gtk_icon_set_add_source(icon_set, icon_source);
+    gtk_icon_factory_add(gIconFactory, stockIcon.get(), icon_set);
+    gtk_icon_set_unref(icon_set);
+    gtk_icon_source_free(icon_source);
+
+    icon = gtk_widget_render_icon(gStockImageWidget, stockIcon.get(),
+                                  icon_size, NULL);
+  }
+
+  if (!icon)
+    return NS_ERROR_NOT_AVAILABLE;
+  
+  nsresult rv = moz_gdk_pixbuf_to_channel(icon, getter_AddRefs(mRealChannel));
+
+  gdk_pixbuf_unref(icon);
+
+  return rv;
+}
