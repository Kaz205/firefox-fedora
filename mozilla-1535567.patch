diff -up firefox-66.0/media/libyuv/libyuv/tools_libyuv/autoroller/unittests/testdata/DEPS.chromium.old firefox-66.0/media/libyuv/libyuv/tools_libyuv/autoroller/unittests/testdata/DEPS.chromium
diff -up firefox-66.0/media/webrtc/trunk/Makefile.old firefox-66.0/media/webrtc/trunk/Makefile
diff -up firefox-66.0/widget/gtk/mozcontainer.cpp.old firefox-66.0/widget/gtk/mozcontainer.cpp
--- firefox-66.0/widget/gtk/mozcontainer.cpp.old	2019-03-14 23:12:56.000000000 +0100
+++ firefox-66.0/widget/gtk/mozcontainer.cpp	2019-03-15 13:23:59.366840324 +0100
@@ -20,6 +20,20 @@
 #  include "maiRedundantObjectFactory.h"
 #endif
 
+#undef LOG
+#ifdef MOZ_LOGGING
+
+#  include "mozilla/Logging.h"
+#  include "nsTArray.h"
+#  include "Units.h"
+
+extern mozilla::LazyLogModule gWidgetLog;
+
+#  define LOG(args) MOZ_LOG(gWidgetLog, mozilla::LogLevel::Debug, args)
+#else
+#  define LOG(args)
+#endif /* MOZ_LOGGING */
+
 #ifdef MOZ_WAYLAND
 using namespace mozilla;
 using namespace mozilla::widget;
@@ -157,10 +171,14 @@ void moz_container_init(MozContainer *co
   container->subsurface = nullptr;
   container->eglwindow = nullptr;
   container->frame_callback_handler = nullptr;
+  container->frame_callback_handler_surface_id = -1;
   // We can draw to x11 window any time.
   container->ready_to_draw = GDK_IS_X11_DISPLAY(gdk_display_get_default());
   container->surface_needs_clear = true;
+  container->inital_draw_cb = nullptr;
 #endif
+
+  LOG(("moz_container_class_init() [%p]\n", (void *)container));
 }
 
 #if defined(MOZ_WAYLAND)
@@ -170,36 +188,92 @@ static wl_surface *moz_container_get_gtk
       dlsym(RTLD_DEFAULT, "gdk_wayland_window_get_wl_surface");
 
   GdkWindow *window = gtk_widget_get_window(GTK_WIDGET(container));
-  return sGdkWaylandWindowGetWlSurface(window);
+  wl_surface *surface = sGdkWaylandWindowGetWlSurface(window);
+
+  LOG(("moz_container_get_gtk_container_surface() [%p] wl_surface %p ID %d\n",
+       (void *)container, (void *)surface,
+       surface ? wl_proxy_get_id((struct wl_proxy *)surface) : -1));
+
+  return surface;
 }
 
 static void frame_callback_handler(void *data, struct wl_callback *callback,
                                    uint32_t time) {
   MozContainer *container = MOZ_CONTAINER(data);
+
+  LOG(
+      ("moz_container_frame_callback_handler() [%p] frame_callback_handler %p "
+       "ready_to_draw %d (set to true) "
+       "inital_draw callback %d\n",
+       (void *)container, (void *)container->frame_callback_handler,
+       container->ready_to_draw, container->inital_draw_cb ? 1 : 0));
+
   g_clear_pointer(&container->frame_callback_handler, wl_callback_destroy);
+  container->frame_callback_handler_surface_id = -1;
+
+  if (!container->ready_to_draw && container->inital_draw_cb) {
+    container->inital_draw_cb();
+  }
   container->ready_to_draw = true;
 }
 
+void moz_container_set_initial_draw_callback(
+    MozContainer *container, std::function<void(void)> inital_draw_cb) {
+  container->inital_draw_cb = inital_draw_cb;
+}
+
 static const struct wl_callback_listener frame_listener = {
     frame_callback_handler};
 
-static gboolean moz_container_map_wayland(GtkWidget *widget,
-                                          GdkEventAny *event) {
-  MozContainer *container = MOZ_CONTAINER(widget);
-
-  if (container->ready_to_draw || container->frame_callback_handler) {
-    return FALSE;
-  }
-
+static void moz_container_request_parent_frame_callback(
+    MozContainer *container) {
   wl_surface *gtk_container_surface =
       moz_container_get_gtk_container_surface(container);
+  int gtk_container_surface_id =
+      gtk_container_surface
+          ? wl_proxy_get_id((struct wl_proxy *)gtk_container_surface)
+          : -1;
+
+  LOG(
+      ("moz_container_request_parent_frame_callback() [%p] "
+       "container->frame_callback_handler %p "
+       "container->frame_callback_handler_surface_id %d\n",
+       (void *)container, container->frame_callback_handler,
+       container->frame_callback_handler_surface_id));
+
+  if (container->frame_callback_handler &&
+      container->frame_callback_handler_surface_id ==
+          gtk_container_surface_id) {
+    return;
+  }
+
+  // If there's pending frame callback, delete it.
+  if (container->frame_callback_handler) {
+    g_clear_pointer(&container->frame_callback_handler, wl_callback_destroy);
+  }
 
   if (gtk_container_surface) {
+    container->frame_callback_handler_surface_id = gtk_container_surface_id;
     container->frame_callback_handler = wl_surface_frame(gtk_container_surface);
     wl_callback_add_listener(container->frame_callback_handler, &frame_listener,
                              container);
+  } else {
+    container->frame_callback_handler_surface_id = -1;
   }
+}
 
+static gboolean moz_container_map_wayland(GtkWidget *widget,
+                                          GdkEventAny *event) {
+  MozContainer *container = MOZ_CONTAINER(widget);
+
+  LOG(("moz_container_map_wayland() begin [%p] ready_to_draw %d\n",
+       (void *)container, container->ready_to_draw));
+
+  if (container->ready_to_draw) {
+    return FALSE;
+  }
+
+  moz_container_request_parent_frame_callback(MOZ_CONTAINER(widget));
   return FALSE;
 }
 
@@ -208,9 +282,12 @@ static void moz_container_unmap_wayland(
   g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
   g_clear_pointer(&container->surface, wl_surface_destroy);
   g_clear_pointer(&container->frame_callback_handler, wl_callback_destroy);
+  container->frame_callback_handler_surface_id = -1;
 
   container->surface_needs_clear = true;
   container->ready_to_draw = false;
+
+  LOG(("moz_container_unmap_wayland() [%p]\n", (void *)container));
 }
 
 static gint moz_container_get_scale(MozContainer *container) {
@@ -227,6 +304,10 @@ static gint moz_container_get_scale(MozC
 
 void moz_container_scale_changed(MozContainer *container,
                                  GtkAllocation *aAllocation) {
+  LOG(("moz_container_scale_changed() [%p] surface %p eglwindow %p\n",
+       (void *)container, (void *)container->surface,
+       (void *)container->eglwindow));
+
   if (!container->surface) {
     return;
   }
@@ -320,6 +401,10 @@ void moz_container_realize(GtkWidget *wi
             : gtk_widget_get_visual(widget);
 
     window = gdk_window_new(parent, &attributes, attributes_mask);
+
+    LOG(("moz_container_realize() [%p] GdkWindow %p\n", (void *)container,
+         (void *)window));
+
     gdk_window_set_user_data(window, widget);
   } else {
     window = parent;
@@ -336,12 +421,8 @@ void moz_container_size_allocate(GtkWidg
 
   g_return_if_fail(IS_MOZ_CONTAINER(widget));
 
-  /*  printf("moz_container_size_allocate %p %d %d %d %d\n",
-      (void *)widget,
-      allocation->x,
-      allocation->y,
-      allocation->width,
-      allocation->height); */
+  LOG(("moz_container_size_allocate() [%p] %d %d %d %d\n", (void *)widget,
+       allocation->x, allocation->y, allocation->width, allocation->height));
 
   /* short circuit if you can */
   container = MOZ_CONTAINER(widget);
@@ -487,8 +568,13 @@ static void moz_container_add(GtkContain
 
 #ifdef MOZ_WAYLAND
 struct wl_surface *moz_container_get_wl_surface(MozContainer *container) {
+  LOG(("moz_container_get_wl_surface() [%p] surface %p ready_to_draw %d\n",
+       (void *)container, (void *)container->surface,
+       container->ready_to_draw));
+
   if (!container->surface) {
     if (!container->ready_to_draw) {
+      moz_container_request_parent_frame_callback(container);
       return nullptr;
     }
     GdkDisplay *display = gtk_widget_get_display(GTK_WIDGET(container));
@@ -526,10 +612,16 @@ struct wl_surface *moz_container_get_wl_
     WaylandDisplayRelease(waylandDisplay);
   }
 
+  LOG(("moz_container_get_wl_surface() [%p] created surface %p\n",
+       (void *)container, (void *)container->surface));
+
   return container->surface;
 }
 
 struct wl_egl_window *moz_container_get_wl_egl_window(MozContainer *container) {
+  LOG(("moz_container_get_wl_egl_window() [%p] eglwindow %p\n",
+       (void *)container, (void *)container->eglwindow));
+
   if (!container->eglwindow) {
     wl_surface *surface = moz_container_get_wl_surface(container);
     if (!surface) {
@@ -543,6 +635,10 @@ struct wl_egl_window *moz_container_get_
                              gdk_window_get_height(window) * scale);
     wl_surface_set_buffer_scale(surface, scale);
   }
+
+  LOG(("moz_container_get_wl_egl_window() [%p] created eglwindow %p\n",
+       (void *)container, (void *)container->eglwindow));
+
   return container->eglwindow;
 }
 
diff -up firefox-66.0/widget/gtk/mozcontainer.h.old firefox-66.0/widget/gtk/mozcontainer.h
--- firefox-66.0/widget/gtk/mozcontainer.h.old	2019-03-14 23:13:02.000000000 +0100
+++ firefox-66.0/widget/gtk/mozcontainer.h	2019-03-15 13:23:59.366840324 +0100
@@ -9,6 +9,7 @@
 #define __MOZ_CONTAINER_H__
 
 #include <gtk/gtk.h>
+#include <functional>
 
 /*
  * MozContainer
@@ -76,8 +77,10 @@ struct _MozContainer {
   struct wl_subsurface *subsurface;
   struct wl_egl_window *eglwindow;
   struct wl_callback *frame_callback_handler;
+  int frame_callback_handler_surface_id;
   gboolean surface_needs_clear;
   gboolean ready_to_draw;
+  std::function<void(void)> inital_draw_cb;
 #endif
   gboolean force_default_visual;
 };
@@ -100,6 +103,8 @@ gboolean moz_container_has_wl_egl_window
 gboolean moz_container_surface_needs_clear(MozContainer *container);
 void moz_container_scale_changed(MozContainer *container,
                                  GtkAllocation *aAllocation);
+void moz_container_set_initial_draw_callback(
+    MozContainer *container, std::function<void(void)> inital_draw_cb);
 #endif
 
 #endif /* __MOZ_CONTAINER_H__ */
